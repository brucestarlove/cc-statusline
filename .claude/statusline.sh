#!/bin/bash
# Generated by cc-statusline v1.4.1 (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2026-01-18T04:35:03.513Z
# Theme: detailed | Colors: true | Features: directory, git, model, context, usage, tokens, burnrate
# FIX: Uses pre-computed color variables to prevent ANSI escape sequence fragmentation
STATUSLINE_VERSION="1.4.1"

input=$(cat)

# ---- check jq availability ----
HAS_JQ=0
if command -v jq >/dev/null 2>&1; then
  HAS_JQ=1
fi

# ---- color variables (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

# Pre-compute color codes as variables to prevent escape sequence fragmentation
if [ "$use_color" -eq 1 ]; then
  CLR_RST=$'\033[0m'
  CLR_DIR=$'\033[38;5;117m'      # sky blue
  CLR_MODEL=$'\033[38;5;147m'    # light purple
  CLR_GIT=$'\033[38;5;150m'      # soft green
  CLR_STAGED=$'\033[38;5;114m'   # green
  CLR_UNSTAGED=$'\033[38;5;215m' # orange/peach
  CLR_NEWFILE=$'\033[38;5;81m'   # cyan
  CLR_SEP=$'\033[38;5;245m'      # gray
  CLR_LINES_ADD=$'\033[38;5;114m' # green
  CLR_LINES_REM=$'\033[38;5;203m' # red
  CLR_COST=$'\033[38;5;222m'     # light gold
  CLR_BURN=$'\033[38;5;220m'     # bright gold
  CLR_SESSION=$'\033[38;5;117m'  # sky blue
  CLR_CTX=$'\033[38;5;158m'      # mint green (default, changes dynamically)
  CLR_USAGE=$'\033[38;5;189m'    # lavender
else
  CLR_RST=""; CLR_DIR=""; CLR_MODEL=""; CLR_GIT=""
  CLR_STAGED=""; CLR_UNSTAGED=""; CLR_NEWFILE=""; CLR_SEP=""
  CLR_LINES_ADD=""; CLR_LINES_REM=""
  CLR_COST=""; CLR_BURN=""; CLR_SESSION=""; CLR_CTX=""; CLR_USAGE=""
fi

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then date -r "$epoch" +"%H:%M"; else date -d "@$epoch" +"%H:%M"; fi
}

progress_bar() {
  pct="${1:-0}"; width="${2:-10}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0; ((pct<0))&&pct=0; ((pct>100))&&pct=100
  filled=$(( pct * width / 100 )); empty=$(( width - filled ))

  # Color gradient based on usage (green -> yellow -> red as it fills up)
  if [ "$use_color" -eq 1 ]; then
    if [ "$pct" -gt 70 ]; then
      bar_color=$'\033[38;5;203m'   # red/coral - danger (>70% used)
    elif [ "$pct" -gt 40 ]; then
      bar_color=$'\033[38;5;222m'   # yellow/gold - caution (40-70% used)
    else
      bar_color=$'\033[38;5;114m'   # green - healthy (<40% used)
    fi
    dim_color=$'\033[38;5;239m'     # dark gray for empty
    reset=$'\033[0m'
  else
    bar_color=''; dim_color=''; reset=''
  fi

  # Build the entire bar as a single string to prevent fragmentation
  local bar_str=""
  for ((i=0; i<filled; i++)); do bar_str+='‚ñì'; done
  local empty_str=""
  for ((i=0; i<empty; i++)); do empty_str+='‚ñë'; done

  # Output atomically with printf %b for escape interpretation
  printf '%b%s%b%b%s%b' "$bar_color" "$bar_str" "$reset" "$dim_color" "$empty_str" "$reset"
}

# git utilities
num_or_zero() { v="$1"; [[ "$v" =~ ^[0-9]+$ ]] && echo "$v" || echo 0; }

# ---- JSON extraction utilities ----
extract_json_string() {
  local json="$1"
  local key="$2"
  local default="${3:-}"
  local field="${key##*.}"
  field="${field%% *}"
  local value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/')
  if [ -n "$value" ]; then
    value=$(echo "$value" | sed 's/\\\\/\//g')
  fi
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*[0-9.]\+" | head -1 | sed 's/.*:[[:space:]]*\([0-9.]\+\).*/\1/')
  fi
  if [ -n "$value" ] && [ "$value" != "null" ]; then
    echo "$value"
  else
    echo "$default"
  fi
}

# ---- basics ----
if [ "$HAS_JQ" -eq 1 ]; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else
  current_dir=$(echo "$input" | grep -o '"workspace"[[:space:]]*:[[:space:]]*{[^}]*"current_dir"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"current_dir"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')
  if [ -z "$current_dir" ] || [ "$current_dir" = "null" ]; then
    current_dir=$(echo "$input" | grep -o '"cwd"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"cwd"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')
  fi
  [ -z "$current_dir" ] && current_dir="unknown"
  current_dir=$(echo "$current_dir" | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | grep -o '"model"[[:space:]]*:[[:space:]]*{[^}]*"display_name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"display_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  [ -z "$model_name" ] && model_name="Claude"
  model_version=""
  session_id=$(extract_json_string "$input" "session_id" "")
  cc_version=$(echo "$input" | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  output_style=$(echo "$input" | grep -o '"output_style"[[:space:]]*:[[:space:]]*{[^}]*"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
fi

# ---- git ----
git_branch=""
git_staged=0
git_unstaged=0
git_new=0
git_lines_added=0
git_lines_removed=0
if git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
  git_staged=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  git_unstaged=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  git_new=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
  diff_stats=$(git diff --numstat HEAD 2>/dev/null | awk '{added+=$1; removed+=$2} END {print added+0, removed+0}')
  git_lines_added=$(echo "$diff_stats" | cut -d' ' -f1)
  git_lines_removed=$(echo "$diff_stats" | cut -d' ' -f2)
fi

# ---- format tokens as k (thousands) ----
fmt_tokens() {
  local n="$1"
  if [ -z "$n" ] || [ "$n" = "0" ]; then
    echo "0"
  elif [ "$n" -ge 1000 ]; then
    awk "BEGIN {printf \"%.1fk\", $n/1000}"
  else
    echo "$n"
  fi
}

# ---- session duration from transcript ----
session_duration=""

# ---- context window calculation (native) ----
context_pct=""
context_remaining_pct=""
context_used_fmt=""
context_size_fmt=""
ctx_input_fmt=""
ctx_output_fmt=""
ctx_cached_fmt=""

if [ "$HAS_JQ" -eq 1 ]; then
  CONTEXT_SIZE=$(echo "$input" | jq -r '.context_window.context_window_size // 200000' 2>/dev/null)
  USAGE=$(echo "$input" | jq '.context_window.current_usage' 2>/dev/null)
  TOTAL_INPUT=$(echo "$input" | jq -r '.context_window.total_input_tokens // 0' 2>/dev/null)
  TOTAL_OUTPUT=$(echo "$input" | jq -r '.context_window.total_output_tokens // 0' 2>/dev/null)

  if [ "$USAGE" != "null" ] && [ -n "$USAGE" ]; then
    CURRENT_TOKENS=$(echo "$USAGE" | jq '(.input_tokens // 0) + (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0)' 2>/dev/null)
    CACHED_TOKENS=$(echo "$USAGE" | jq '(.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0)' 2>/dev/null)

    if [ -n "$CURRENT_TOKENS" ] && [ "$CURRENT_TOKENS" -gt 0 ] 2>/dev/null; then
      context_used_pct=$(( CURRENT_TOKENS * 100 / CONTEXT_SIZE ))
      context_remaining_pct=$(( 100 - context_used_pct ))
      (( context_remaining_pct < 0 )) && context_remaining_pct=0
      (( context_remaining_pct > 100 )) && context_remaining_pct=100

      # Set context color based on remaining percentage
      if [ "$use_color" -eq 1 ]; then
        if [ "$context_remaining_pct" -le 20 ]; then
          CLR_CTX=$'\033[38;5;203m'  # coral red
        elif [ "$context_remaining_pct" -le 40 ]; then
          CLR_CTX=$'\033[38;5;215m'  # peach
        else
          CLR_CTX=$'\033[38;5;158m'  # mint green
        fi
      fi

      context_pct="${context_remaining_pct}%"
      context_used_fmt=$(fmt_tokens "$CURRENT_TOKENS")
      context_size_fmt=$(fmt_tokens "$CONTEXT_SIZE")
      ctx_input_fmt=$(fmt_tokens "$TOTAL_INPUT")
      ctx_output_fmt=$(fmt_tokens "$TOTAL_OUTPUT")
      ctx_cached_fmt=$(fmt_tokens "$CACHED_TOKENS")
    fi
  fi

  # Calculate session duration from transcript timestamps
  TRANSCRIPT_PATH=$(echo "$input" | jq -r '.transcript_path // ""' 2>/dev/null)
  if [ -n "$TRANSCRIPT_PATH" ] && [ -f "$TRANSCRIPT_PATH" ]; then
    first_ts=$(head -50 "$TRANSCRIPT_PATH" | jq -r 'select(.timestamp) | .timestamp' 2>/dev/null | head -1)
    last_ts=$(tail -50 "$TRANSCRIPT_PATH" | jq -r 'select(.timestamp) | .timestamp' 2>/dev/null | tail -1)

    if [ -n "$first_ts" ] && [ -n "$last_ts" ]; then
      first_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${first_ts%%.*}" +%s 2>/dev/null)
      if [ -z "$first_epoch" ]; then
        first_epoch=$(date -d "$first_ts" +%s 2>/dev/null)
      fi
      last_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${last_ts%%.*}" +%s 2>/dev/null)
      if [ -z "$last_epoch" ]; then
        last_epoch=$(date -d "$last_ts" +%s 2>/dev/null)
      fi

      if [ -n "$first_epoch" ] && [ -n "$last_epoch" ] && [ "$last_epoch" -ge "$first_epoch" ]; then
        duration_sec=$((last_epoch - first_epoch))
        if [ "$duration_sec" -lt 60 ]; then
          session_duration="<1m"
        else
          duration_min=$((duration_sec / 60))
          hours=$((duration_min / 60))
          mins=$((duration_min % 60))
          if [ "$hours" -eq 0 ]; then
            session_duration="${mins}m"
          elif [ "$mins" -eq 0 ]; then
            session_duration="${hours}h"
          else
            session_duration="${hours}h ${mins}m"
          fi
        fi
      fi
    fi
  fi
fi

# ---- cost and usage extraction ----
session_txt=""; session_pct=0; session_bar=""
cost_usd=""; cost_per_hour=""; tpm=""; tot_tokens=""

if [ "$HAS_JQ" -eq 1 ]; then
  cost_usd=$(echo "$input" | jq -r '.cost.total_cost_usd // empty' 2>/dev/null)
  total_duration_ms=$(echo "$input" | jq -r '.cost.total_duration_ms // empty' 2>/dev/null)

  if [ -n "$cost_usd" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    cost_per_hour=$(echo "$cost_usd $total_duration_ms" | awk '{printf "%.2f", $1 * 3600000 / $2}')
  fi

  input_tokens=$(echo "$input" | jq -r '.context_window.total_input_tokens // 0' 2>/dev/null)
  output_tokens=$(echo "$input" | jq -r '.context_window.total_output_tokens // 0' 2>/dev/null)

  if [ "$input_tokens" != "null" ] && [ "$output_tokens" != "null" ]; then
    tot_tokens=$(( input_tokens + output_tokens ))
    [ "$tot_tokens" -eq 0 ] && tot_tokens=""
  fi

  if [ -n "$tot_tokens" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    tpm=$(echo "$tot_tokens $total_duration_ms" | awk '{if ($2 > 0) printf "%.0f", $1 * 60000 / $2; else print ""}')
  fi
else
  cost_usd=$(echo "$input" | grep -o '"total_cost_usd"[[:space:]]*:[[:space:]]*[0-9.]*' | sed 's/.*:[[:space:]]*\([0-9.]*\).*/\1/')
  total_duration_ms=$(echo "$input" | grep -o '"total_duration_ms"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')

  if [ -n "$cost_usd" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    cost_per_hour=$(echo "$cost_usd $total_duration_ms" | awk '{printf "%.2f", $1 * 3600000 / $2}')
  fi

  input_tokens=$(echo "$input" | grep -o '"total_input_tokens"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')
  output_tokens=$(echo "$input" | grep -o '"total_output_tokens"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')

  if [ -n "$input_tokens" ] && [ -n "$output_tokens" ]; then
    tot_tokens=$(( input_tokens + output_tokens ))
    [ "$tot_tokens" -eq 0 ] && tot_tokens=""
  fi

  if [ -n "$tot_tokens" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    tpm=$(echo "$tot_tokens $total_duration_ms" | awk '{if ($2 > 0) printf "%.0f", $1 * 60000 / $2; else print ""}')
  fi
fi

# ---- render statusline ----
# Build entire output as a single string, then output atomically

# Line 1: Directory, git branch + git status indicators
line1="üìÅ ${CLR_DIR}${current_dir}${CLR_RST}"
if [ -n "$git_branch" ]; then
  line1="${line1}  üåø ${CLR_GIT}${git_branch}${CLR_RST}"
  line1="${line1} ${CLR_SEP}|${CLR_RST} ${CLR_STAGED}‚úì:${CLR_RST} ${git_staged} ${CLR_SEP}|${CLR_RST} ${CLR_UNSTAGED}‚úé:${CLR_RST} ${git_unstaged} ${CLR_SEP}|${CLR_RST} ${CLR_NEWFILE}+:${CLR_RST} ${git_new}"
  line1="${line1} ${CLR_SEP}|${CLR_RST} ${CLR_LINES_ADD}+${git_lines_added}${CLR_RST} ${CLR_LINES_REM}-${git_lines_removed}${CLR_RST}"
fi

# Line 2: Model + Context with token breakdown
line2="ü§ñ ${CLR_MODEL}${model_name}${CLR_RST}"
if [ -n "$context_pct" ]; then
  context_bar=$(progress_bar "$context_used_pct" 10)
  line2="${line2}  ${CLR_CTX}${context_used_pct}%${CLR_RST} ${context_bar} ${CLR_CTX}${context_used_fmt}/${context_size_fmt}${CLR_RST}"
  line2="${line2} ${CLR_SEP}|${CLR_RST} In: ${ctx_input_fmt} ${CLR_SEP}|${CLR_RST} Out: ${ctx_output_fmt}"
else
  line2="${line2}  ${CLR_CTX}--% ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë --/--${CLR_RST}"
fi

# Line 3: Cost + Session duration
line3=""
if [ -n "$cost_usd" ] && [[ "$cost_usd" =~ ^[0-9.]+$ ]]; then
  cost_fmt=$(printf '%.2f' "$cost_usd")
  if [ -n "$cost_per_hour" ] && [[ "$cost_per_hour" =~ ^[0-9.]+$ ]]; then
    cph_fmt=$(printf '%.2f' "$cost_per_hour")
    line3="üí∞ ${CLR_COST}\$${cost_fmt}${CLR_RST} (${CLR_BURN}\$${cph_fmt}/h${CLR_RST})"
  else
    line3="üí∞ ${CLR_COST}\$${cost_fmt}${CLR_RST}"
  fi
fi
if [ -n "$session_duration" ]; then
  if [ -n "$line3" ]; then
    line3="${line3}  ‚è±Ô∏è  ${CLR_SESSION}${session_duration}${CLR_RST}"
  else
    line3="‚è±Ô∏è ${CLR_SESSION}${session_duration}${CLR_RST}"
  fi
fi

# Output everything in ONE atomic printf call
output="${line1}"
[ -n "$line2" ] && output="${output}
${line2}"
[ -n "$line3" ] && output="${output}
${line3}"

printf '%b\n' "$output"
